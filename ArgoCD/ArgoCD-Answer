Argo CD – Real-Time Project Explanation

1.In our project, we used Argo CD as a GitOps-based Continuous Delivery tool to deploy applications to Kubernetes.
All Kubernetes manifests and Helm charts were stored in a Git repository, which acted as the single source of truth.

2.Argo CD was configured to continuously monitor the Git repository.
3.Whenever any changes occurs such as an image tag update, replica change, or configuration update—Argo CD automatically synchronized those changes to the Kubernetes 
cluster. In critical environments like production, we used manual approval sync, while dev and QA used auto-sync.

4. We used one Argo CD to manage multiple Kubernetes environments like dev, QA, and production.

Each environment had its own Argo CD application, and it was connected to a specific Git branch or folder.

Argo CD gave us a web UI where we could easily:

See whether the application was healthy or not

Check if the cluster and Git were in sync

Manually sync changes when needed

Rollback to a previous version if something went wrong

If someone changed anything directly in the Kubernetes cluster, Argo CD automatically detected the difference and fixed it by restoring the Git version.
This helped us keep everything consistent and controlled.

For rollbacks, we just reverted the change in Git, and Argo CD automatically deployed the earlier stable version.
_______________________________________________________________________________________
ARGOCD Architecture:
Argo CD Components:

argocd-server → Web UI + API.
application-controller → Syncs Git with cluster.
repo-server → Fetches Git repo, processes Helm/Kustomize.
Redis → Cache for performance.

__________________________________________How Argo CD Works **
You define your Kubernetes YAML in Git.
Argo CD pulls those files.
It compares Git (desired state) vs Cluster (live state).
If different → you sync manually or auto-sync.
If auto-sync + self-heal → it updates automatically.
