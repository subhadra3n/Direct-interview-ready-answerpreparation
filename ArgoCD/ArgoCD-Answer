Argo CD – Real-Time Project Explanation

1.In our project, we used Argo CD as a GitOps-based Continuous Delivery tool to deploy applications to Kubernetes.
All Kubernetes manifests and Helm charts were stored in Git, which acted as the single source of truth.

2.Argo CD was configured to continuously monitor the Git repository.

3.Whenever there were changes such as image tag updates, replica count changes, or configuration updates, Argo CD automatically synced those changes to the Kubernetes cluster.

4.We used a single Argo CD instance to manage multiple Kubernetes environments like dev, QA, and production.
Each environment had its own Argo CD application, connected to a specific Git branch or folder.

.Argo CD provided a web-based UI where we could:

i.Track application health

ii.Check whether Git and the cluster were in sync

iii.Manually trigger syncs when required

iv.Rollback to a previous version if something went wrong

5.If someone made manual changes directly in the Kubernetes cluster, Argo CD detected the drift and reverted it back to the Git-defined state, ensuring consistency and control.

6.For rollbacks, we simply reverted the Git commit, and Argo CD automatically redeployed the previous stable version.

 (In critical environments like production, we used manual approval sync, while dev and QA used auto-sync.)not req@@
_______________________________________________________________________________________
ARGOCD Architecture:
Argo CD Components:

argocd-server → Web UI + API.
application-controller → Syncs Git with cluster.
repo-server → Fetches Git repo, processes Helm/Kustomize.
Redis → Cache for performance.

__________________________________________How Argo CD Works **
You define your Kubernetes YAML in Git.
Argo CD pulls those files.
It compares Git (desired state) vs Cluster (live state).
If different → you sync manually or auto-sync.
If auto-sync + self-heal → it updates automatically.
